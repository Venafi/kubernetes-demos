# Configuring and running Venafi fireflyCA 

## Requirements  
- You are licensed to use Venafi TLS Protect for Kubernetes and have the credentials to pull enterprise cert-manager images from Venafi's private registry
- You have access to Venafi TLS Protect Cloud and the **fireflyCA** addon to create intermediate CA's along with policies to govern them. 

## Assumptions 
- For the purposes of this demo, **fireflyCA** will be configured to run in Kubernetes along with the rest of the workloads. In production environemnts it is recommended to isolate **fireflyCA** by running it in a dedicated nodepool or outside of the cluster in it's own VM or physical machine. When running outside the cluster fireflyCA will authenticate using `kubeconfig` associated with the `ServiceAccount` tied to fireflyCA `Deployment`
- `CertificateRequest` resources will comply to the policies associated with fireflyCA configured in Venafi Control Plane. Most enterprises also run Venafi policies in-cluster with Venafi TLSPK Enterprise Policy Approver. If `policy-approver` is deployed in cluster, a `CertificateRequestPolicy` must be created that allows all for the **fireflyCA** issuer to avoid conflicting policies.    

## Configuring Venafi fireflyCA 
Login into [Venafi TLS Protect Cloud](https://ui.venafi.cloud) and access the **fireflyCA** addon from the product switcher in the upper right corner. If you don't have an account you can sign up for a 30 day trial.

![fireflyCA in TLS Protect Cloud](../images/fireflyCA-initial.png)

You can switch between TLS Protect Cloud and fireflyCA at any time. You will be presented with the last accessed module when you login.

### Creating a Sub CA Provider 
The first step to getting started with **fireflyCA** is to create a subordinate CA provider. Several upstream CA's are supported but for the purposes of setting up this demo environment 
- Click "Sub CA Providers" in the top menu
- Click the "New" -> "Venafi Built-In CA" button. 

> **NOTE** 
> Sub CA Provider can be created using the Venafi API as well. There are several helper `Makefile` targets showing how to use the Venafi APIs. [Venafi Developer Central](https://developer.venafi.com) is a good place to start to understand the various APIs and recipes that can be used. 

In the presented screen provide the details for the subordinate CA. An example is included in the screenshot below. The common name for the CA that will be bootstrapped is set as `fireflyca.svc.cluster.local` with the key algorithm as `EC P256`. Set the rest of the subject information that best suits your needs. 

![Creating a Sub CA Provider](../images/firefly-subca-config.png)

Make sure to save and review the Sub CA Provider you create. 
### Create a policy for certificates issued by fireflyCA
As a next step , we will create a policy that will be used by the **fireflyCA** issuer for issuing certificates in cluster. Venafi fireflyCA provides a very comprehensive policy model for governing how certificates are issued for workloads. Read the TLS Protect Cloud documentation for various options. 

To create a policy 
- Click "Policies" in the top menu
- Click New and in the presented screen provide the values for the policy. 

All fields are self explanatory. For information about what the "Type" means read the documentation. In the sample policy shown below 
- the name of the policy is *fireflyca-demo-policy*
- the validity of all certs issued by **fireflyCA** is 7 days 
- the subject enforces that common name / DNS SAN must end with `.svc.cluster.local`
- the rest of the subject fields are locked to a certain value and the information provided in the CSR will be not used. 
- the key constraint is set to "Required" and the only allowed value is **EC P256**
- the issuance parameters are set with specific values that will be set in the issued certificate.

![fireflyCA Policy](../images/fireflyca-policy.png)

Make sure to save and review the policy you create. 

### Creating a configuration for fireflyCA runtime operations
This is the final step in the process of setting up fireflyCA for runtime operation. **fireflyCA** at runtime is associated with a configuration that holds one or more policies. Note that in this demo we created only one policy. It is likely that in production environments there will be multiple policies catering to different type of workloads associated with a single configuration. For e.g the policy we created above issues certs with validity of 7 days. There could be other types of certificates with different validity periods created as policies and associated with a configuration. 

To create a configuration,
- Click "Configurations" in the top menu 
- Click New and in the presented screen provide a name and the required fields. 

The required fields on the screen are self explanatory. For addtional details, read the documentation. 
- the name of the config is set to `firefly-demo-config`
- the selected Sub CA Provider is what we created as a Sub CA Provider
- the associated policy is the policy we created earlier. 

The screenshot below shows the sample configuration used for this demo.  Note the metrics below the name of the configuration. As **fireflyCA** runs, metrics associated with number of certificates issued is shown when you return to the configuration. 

> **Warning**
>At the time of this writing, OIDC discovery is not supported and you can fill in anything as it is a required field. 

![fireflyCA Configuration](../images/fireflyca-config.png)

Make sure to save and review the configuration you create. 

## Installing the required fireflyCA components in Kubernetes

- This demo instructions was created with a cluster running in Amazon EKS. 
- The [resources](../firefly/config/firefly-resources.yaml) to deploy **fireflyCA** was generated using `helm template`. In the near future the instructions will be changed to install via helm instead of static manifests
- While the **fireflyCA** demo can be deployed standalone, it is part of the larger demo set that is in this repo and utilizes the same `settings.sh-template` for configuring the environment. If you don't care about rest of the demos, you don't need to setup all the required variables in your local `settings.sh`
- You are still required to set the variables used in [Makefile](../firefly/Makefile) in `settings.sh`. All variables start with prefix **JS_**
- Running **fireflyCA** in Kubernetes requires enterprise cert-manager (available via TLS Protect Kubernetes) and some of the variables set in `settings.sh` is for connecting to Venafi's private registry to pull images. 
- Instructions to get credentils to access enterprise builds are [here](../README.md#assumptions)

### Setting up the environment 
- Follow the instructions to set up your local environment [here](../README.md#setting-up-your-environment)
- More specifically to run **fireflyCA** you will need to set 
  - JS_ENTERPRISE_CREDENTIALS_FILE (Docker registry secret downloaded from TLS Protect for Kubernetes)
  - JS_DOCKER_REGISTRY_EMAIL (Any email id that will be set as --docker-email in the docker-registry secret)
  - JS_VENAFI_CLOUD_API_KEY (Your Venafi TLS Protect Cloud API Key)
  - JS_VENAFI_FIREFLYCA_CONFIG_ID (The config id of Venafi fireflyCA config)

### Preparing the cluster to run fireflyCA

### STEP 1
Change to directory `firefly`. Instructions assume that you are running everything from the directory `demos/firefly`

Run 
```
make init
```
Running `init` will 
- create a directory called `artifacts` and all the necessary files required to deploy **fireflyCA** will be generated here. 
- create two namespaces in your cluster `sandbox` and `cert-manager` 
- configure the `cert-manager` to have a `Secret` called `docker-registry` that will contain the credentials to pull Venafi TLS Protect for Kubernetes images. For the purpose of this demo the only image that will be pulled is the enterprise cert-manager

### STEP 2
Review the file [create-kube-config.sh](../firefly/create-kube-config.sh) 
What does `create-kube-config.sh` do?
- It checks if a service account called `firefly-ca` exists in the namespace `cert-manager`
- If it doesn't exist it creates one
- It then creates a service account token mapped to `ServiceAccount` `firefly-ca`
- Finally, it generates a configuration using the client certificate from the token to create a `kubeconfig`. 
- Most importantly, it ties the `ServiceAccount` associated with **fireflyCA** `Deployment` to the token for the required RBAC's. Essentially this `kubeconfig` represents the service account `firefly-ca` used by the `Deployment` 

Running the following target **DOES NOT** create the kubeconfig. It only prints the command for you to run. Only you have the credentials to run it. 

Run 
```
make create-kubeconfig
```
You will see the following output 
```
Create kubeconfig. Run the shell script like this... 
Replace CLUSTER_FULLNAME with your cluster name and CLUSTER_URL with your cluster URL. Example below

CLUSTER_FULLNAME=arn:aws:eks:<your-region>:<your-account>:cluster/<your-cluster-name> CLUSTER_URL=https://<whatever-you-see-in-the-url>.eks.amazonaws.com ./create-kube-config.sh

The Service account associcated kubeconfig is generated - written to console as well as to file artifacts/kubeconfig.yaml
```
Replace the value of **CLUSTER_NAME** with your cluster name and the **CLUSTER_URL** with your cluster URL. The example above is for EKS but replace it with relevant cluster name and url for other Kubernetes distributions. 

You should see a new file called `artifacts/kubeconfig.yaml`. Review it. 
Additionally, run 
```
kubectl get sa -n cert-manager
```
and you will see

```
NAME                      SECRETS   AGE
default                   0         54s
firefly-ca                0         12s
```
If you want to inspect the associated token optionally, run 

```
kubectl -n cert-manager get secret -o jsonpath='{.items[?(@.metadata.annotations.kubernetes\.io/service-account\.name=="firefly-ca")].metadata.name}'
```
and you will see `firefly-ca-token-<random-uid>` 

### STEP 3

**fireflyCA** requires cert-managaer to be installed and running. This step installs cert-manager for you. While this demo instructions installs cert-manager in the `cert-manager` namespace our install instructions for TLS Protect Kubernetes will be in a different namespace. At the time of this writing **fireflyCA** assumes cert-manager runs in the `cert-manager` namespace. This will be resolved. 

Run
```
make install-cert-manager
```
Successful installation of cert-manager will return the control back to your console. 

To review that cert-manager is deployed and all pods are `Running`, run

```
kubectl get pods -n cert-manager
```
to see
```
NAME                                       READY   STATUS    RESTARTS   AGE
cert-manager-cainjector-68847fbb5b-lpbhw   1/1     Running   0          9m
cert-manager-cfc9ff49d-4hrlm               1/1     Running   0          9m
cert-manager-webhook-97984bd5b-5rs7v       1/1     Running   0          9m
```

### STEP 4

Before executing this step review the configuration for fireflyCA. The config is in [config/firefly-config.yaml](../firefly/config/firefly-config.yaml)

There is nothing to change here. The values will be replaced and a new file generated in the artifacts directory. 
Note that property called `instanceNaming`. The name set here will be prepended to the `CommonName` that we set when we created the Sub CA provider. For e.g the issuing certificate will be named `<timewhenrun> fireflyca.svc.cluster.local` 

Additionally, if interested review the resources that will be deployed. All firefly resources are located in [config/firefly-resources.yaml](../firefly/config/firefly-resources.yaml)

> **NOTE** 
> `firefly-resources.yaml` is generated via a Helm Chart that is currently (at the time of this writing) not published. Once published this file will be deleted and the deployment will be done via `helm install`

To deploy **fireflyCA**  run,

```
make deploy-firefly
```
The output of the deploying **fireflyCA** will look like below
```
configmap/firefly-ca-config created
Warning: resource serviceaccounts/firefly-ca is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.
serviceaccount/firefly-ca configured
customresourcedefinition.apiextensions.k8s.io/issuers.firefly-ca.venafi.com created
clusterrole.rbac.authorization.k8s.io/firefly-ca:approver-firefly-ca-venafi-com created
clusterrole.rbac.authorization.k8s.io/firefly-ca created
clusterrolebinding.rbac.authorization.k8s.io/firefly-ca:approver-firefly-ca-venafi-com created
clusterrolebinding.rbac.authorization.k8s.io/firefly-ca created
role.rbac.authorization.k8s.io/firefly-ca:leader-election created
rolebinding.rbac.authorization.k8s.io/firefly-ca:leader-election created
deployment.apps/venafi-firefly-ca created
```
Several resources will be created to setup the appropriate RBAC controls for the deployment. 

Review that **fireflyCA** is indeed deployed by running

```
kubectl get pods -n cert-manager
```
and you will see

```
NAME                                       READY   STATUS    RESTARTS   AGE
cert-manager-cainjector-68847fbb5b-lpbhw   1/1     Running   0          45s
cert-manager-cfc9ff49d-4hrlm               1/1     Running   0          45s
cert-manager-webhook-97984bd5b-5rs7v       1/1     Running   0          45s
venafi-firefly-ca-6c94f8699d-26pm6         1/1     Running   0          6s
```

Additionally, review the log by running
```
kubectl logs venafi-firefly-ca-6c94f8699d-26pm6 -n cert-manager
```
Partial output at the end will say something like this that tells **fireflyCA** is deployed and running as expected. 

```
I0325 15:03:17.874875       1 client.go:322] agent/bootstrap/vaas/client "msg"="retrieve issued intermediate certificate from VaaS" 
E0325 15:03:17.950728       1 client.go:559] agent/bootstrap/vaas "msg"="failed to execute the call, will retry" "error"="intermediate certificate with id 2cbd1500-cb1e-11ed-9258-af4582eca766 is not yet issued, current status: PENDING" 
I0325 15:03:18.451713       1 client.go:322] agent/bootstrap/vaas/client "msg"="retrieve issued intermediate certificate from VaaS" 
I0325 15:03:18.527740       1 vaas.go:122] agent/bootstrap/vaas "msg"="issued intermediate certificate from VaaS" "CN"="2023-03-25-1003 fireflyca.svc.cluster.local" "id"="2cbd1500-cb1e-11ed-9258-af4582eca766"
I0325 15:03:18.528294       1 inmemory.go:47] agent/signer/inmemory "msg"="stored in memory certificate private key bundle" 
I0325 15:03:18.528330       1 renewer.go:171] agent/agent_renewer "msg"="waiting to renew certificate" "renew_time"="2023-04-14 15:03:08 +0000 UTC"
```

### STEP 5
Let's validate that the **fireflyCA** can issue certificates 

Review the file [config/certificate.yaml](../firefly/config/certificate.yaml) 

**IMPORTANT** The `policy-name` annotation drives what policy is used for fulling the certificate request. The teams requesting certificates just need to know the name of the policy and the required properties to send in the certificate. Many of the certificate properties have been locked by the administrator and/or set as defaults. 

Run 
```
make create-certificates
```

This will create the certificates in the `sandbox` namespace and can be validated by running,

```
kubectl get Certificate -n sandbox
```
The output will be 

```
NAME                           READY   SECRET                         AGE
test-cert1.svc.cluster.local   True    test-cert1.svc.cluster.local   1m
test-cert2.svc.cluster.local   True    test-cert2.svc.cluster.local   1m
test-cert3.svc.cluster.local   True    test-cert3.svc.cluster.local   1m
```
Optionally, look at the associated `CertificateRequest` and `Secret` resources. 
To look at `CertificateRequest` resources run 

```
kubectl get CertificateRequests -n sandbox 
```
The output will be

```
NAME                                 APPROVED   DENIED   READY   ISSUER      REQUESTOR                                         AGE
test-cert1.svc.cluster.local-955pc   True                True    fireflyCA   system:serviceaccount:cert-manager:cert-manager   1m
test-cert2.svc.cluster.local-hdfw2   True                True    fireflyCA   system:serviceaccount:cert-manager:cert-manager   1m
test-cert3.svc.cluster.local-8vfct   True                True    fireflyCA   system:serviceaccount:cert-manager:cert-manager   1m
```
Note that the issuer is set to **fireflyCA**

## Access the Venafi Control Plane to review the 

To view the Issuer Certificates and the associated metrics,
- Click "Issuer Certificates" in the top menu 

All the Issuer certificates and the metrics will be presented for the security team to monitor and review as shown below 

![Certs issued by fireflyCA](../images/firefly-certs-issued.png)

If TLS Protect for Kubernetes agent is deployed in-cluster, the dashboard will show the certificate details.  Login to TLSPK dashboard for detailed access to each certificate. 

## Cleanup
To clean up everything in your Kubernetes cluster, just run

```
make cleanup
```
If you also want to clean up the issuing certificates from TLS Protect Cloud there are a couple of helper targets. 

Run `make get-firefly-intermediate-certificate-ids`. This will list the id and common name for all issuing certificates 
Then change the target `make delete-firefly-intermediateCertificates` to set the id and run. 